
Android:
b站的"Google中国"：https://space.bilibili.com/64169458?spm_id_from=333.788.b_765f7570696e666f.1
b站的扔物线：https://space.bilibili.com/27559447?spm_id_from=333.788.b_765f7570696e666f.1

kotlin：
极客熊猫：https://juejin.im/user/5879cfcd5c497d0058984421/posts
扔物线_码上开学：https://kaixue.io/tag/kotlin-basic/

jetpack：
Flywith24：https://juejin.im/user/57c7f6870a2b58006b1cfd6c
HiDhl：https://juejin.im/user/56aa2464816dfa00595a8d14
依然范特稀西：https://juejin.cn/user/1204720443862887/posts
ViewBinding:https://mp.weixin.qq.com/s/BSdzKSOiAWG08epvXN5q2w

恋猫de小郭:
https://juejin.im/user/817692379985752

JessYan(屏幕适配):
https://juejin.cn/user/976022014539326

Google:
MAD Skills（Modern Android Development）: https://madskills.hi-dhl.com/#/

设计模式：https://blog.csdn.net/itachi85/article/details/50491657


retofit:
1. 请求方法只能定义在接口中，接口及其父接口不能声明泛型
2. 严格的检查机制，不能是默认方法（java8的接口新特性就不能用了）
3. 错误快速暴露（方便测试，调试），默认情况下接口的方法在首次被调用会被检查，后续重复调用不再检查；
   Retofit#validateEagerly变量（默认不开启）会在执行Retofit#create()对接口的每个方法进行检查，这种比较耗时。
4. 核心设计模式：动态代理
5. 是对okhttp进行了一层封装。如enqueue()方法其实内部调用了okhttp的enqueue()方法
6. 内部使用Executor开辟线程进行网络请求，请求结果使用主Looper的Handle调用回调。